\documentclass[conference]{IEEEtran-ModifiedForMVIP}
% این فایل از روی نمونه‌ فایل ارائه شده برای کنفرانس مهندسی برق ایران ICEE 
% برای کنفرانس بینایی ماشین و پردازش تصویر ایران به‌روزرسانی شده است.
% فایل منبع و فایلهای ضمیمه‌ی آن با تغییر فایلهایی که توسط آقای دکتر محمود امین طوسی (دانشگاه
% حکیم سبزواری، http://profs.hsu.ac.ir/mamintoosi) در سایت www.parsilatex.com قرار داده 
% شده بودند به دست آمده است. این تغییرات توسط دکتر مسعود بابایی‌زاده داده شده است. 
% البته فایل IEEEtran-ModifiedForICEE.cls در اینجا، 
% اصلاح شده فایل آقای دکتر امین طوسی نیست و مستقیما با دستکاری
% در فایل IEEEtran.cls توسط مسعود بابایی زاده ایجاد شده است.
% برای کنفرانس بینایی ماشین و پردازش تصویر ایران، فایل IEEEtran-ModifiedForICEE.cls 
% با نام IEEEtran-ModifiedForMVIP.cls  تغییر داده شده است.

% مقاله اصلی که این فایل از تغییر فایل آن به دست آمده است، در هفدهمین کنفرانس مهندسی برق 
% ایران در اردیبهشت ۸۸ ارائه شده بوده است.

% شما می‌توانید از این فایل به عنوان یک الگو برای مقالات خود استفاده نمایید.

% برای پردازش پس از یکبار استفاده از xelatex با استفاده از دستور زیر لیست مراجع را تولید نمایید:
% bibtex MVIP_FA_LaTeX_SamplePaper
% و سپس دوبار استفاده از xelatex. 

%%%% فراخوانی پکیج‌های مورد نیاز کاربر %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{setspace}
\usepackage{subfigure}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{pdfpages}
%\usepackage[colorlinks, citecolor=blue]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% فراخوانی تنظیمات مورد نیاز کنفرانس مهندسی برق ایران و پکیج زی‌پرشین %%%%%%%%%%%%%%%%
\input{MVIP_Settings1.tex}
% یکی از دو روش زیر را انتخاب کنید. گذاشتن حالت «کشیده» باعث می‌شود که تنطیم
% طول خطها بجای اینکه با کم و زیاد کردن فاصله بین کلمات انجام شود، با کشیدن
% کلمات انجام شود. این حالت در فارسی صحیح‌تر و خیلی زیباتر است (برخلاف انگلیسی که کشیدن کلمات
% در آن معنی ندارد و تنطیم طول خطوط فقط با کم و زیاد کردن فاصله بین کلمات صورت
% می‌گیرد). اما با استفاده از حالت «کشیده»، اگر از Acrobat Adobe برای دیدن خروجی پی‌دی‌اف
% استفاده کنید این کشیده‌ها را می‌بینید که چندان زیبا نیست (در نسخه چاپی وجود ندارند).
% اگر می‌خواهید اینها را نبینید در قسمت  Edit->Preferences->PageDisplay گزینه
% Enhance Thin Lines
% را غیرفعال کنید. اما اگر از SumatraPDF برای دیدن فایل پی‌دی‌اف استفاده می‌کنید، تنظیم خاصی
% نیاز نیست.
\usepackage[Kashida]{xepersian}
% \usepackage{xepersian}
\input{MVIP_Settings2.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% تعریف دستورات جدید مورد نیاز کاربر %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\femph[1]{\lr{''}#1\lr{``}}
\newcommand{\SR}{وضوحِ برتر}%{\textiranic{ وضوحِ برتر }}
\newcommand{\HR}{وضوح بالا}
\newcommand{\registration}{ثبت تصویر}
\newcommand{\fusion}{آمیختن}
\newcommand{\fused}{آمیخته}

\newcommand{\warp}{\mathbf{W}(\mathbf{x};\mathbf{p})}
\newcommand{\IWarp}{I(\mathbf{W}(\mathbf{x};\mathbf{p}))}
\newcommand{\round}[2]{\frac{\partial{#1}}{\partial{#2}}}
\newcommand{\roundB}[2]{\frac{\partial{\mathbf{#1}}}{\partial{\mathbf{#2}}}}


\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% شروع متن اصلی %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
% دستور زیر باعث امکان استفاده از \thanks می‌شود.
\IEEEoverridecommandlockouts 

\title{
طراحی و پیاده‌سازی ضرب‌کنندهٔ ماتریس توسط Verilog
}

\author{
\IEEEauthorblockN{
احمد سلیمی
\textsuperscript{1}،
کیمیا نوربخش
\textsuperscript{1}،
ساعی سعادت
\textsuperscript{1}،
علیرضا حسین‌پور
\textsuperscript{1}
}
\IEEEauthorblockA{\textsuperscript{1}
دانشگاه صنعتی شریف، دانشکده مهندسی کامپیوتر}
}

%\date{}
\maketitle
% چکیده مقاله
\begin{abstract}
\end{abstract}
\begin{IEEEkeywords}
% کلمات کلیدی
\end{IEEEkeywords}

%\IEEEpeerreviewmaketitle

\section{مقدمه}
هدف این پروژه، طراحی، شبیه‌سازی و سنتز یک ضرب‌کنندهٔ ماتریس با زبان وریلاگ است.
از کاربرد‌های چنین ضرب‌کنند‌ه‌ای می‌توان
به آموزش مدل‌های شبکه‌های عصبی 
\LTRfootnote{\lr{Neural Networks}}
اشاره کرد.
از آن‌جایی که ماتریس‌ وزن‌ها در شبکه‌های عصبی ابعاد بالایی دارند، طراحی یک ضرب‌کننده که هم بتواند در زمان کوتاه پاسخ را آماده کند و 
هم از نظر سخت افزاری بهینه باشد، از اهمیت بالایی برخوردار است.
\\
روشی که در این پروژه به کاربرده شده است، تقسیم بندی ماتریس به بلوک‌های مربعی و استفاده از خاصیت بلوکی در ضرب ماتریس‌‌ها است. 
ساختار این ضرب‌کننده از 4 لایه تشکیل شده است. بالاترین لایه، لایه ضرب کننده ماتریس موازی است، لایه بعدی ضرب‌کننده 
ماتریس سطری و ستونی است. لایه سوم ضرب‌کننده ماتریس ترتیبی و لایه آخر ضرب‌کننده و جمع‌کننده‌
\lr{floating point}
است.\\
در ادامه و در بخش 2، ابتدا به معماری سیستم و نحوه طراحی ماژول‌های آن پرداخته می‌شود. در بخش 3، به نحوه انجام شبیه‌سازی‌ها
و نتایج حاصل از آن‌ها پرداخته شده است و در نهایت، در بخش 4، به نحوه انجام عملیات سنتز این سیستم روی 
\lr{FPGA}
و نتایج حاصل اشاره شده‌است.
\section{معماری سیستم}

معماری این سیستم، از سه لایهٔ اصلی تشکلی شده‌است. در ادامه، معماری و جزئیات هر یک از این لایه‌ها، توضیح داده شده است.
\\
برای ارتباط بین تمامی ماژول‌ها، برای اطمینان از این که ورودی و خروجی‌ها هنگام استفاده شدن تغییر نمی‌کنند و مقدار صحیحی دارند، برای هر کدام دو سیگنال stable و acknowledge در نظر می‌گیریم.
نحوه‌ی استفاده از آن‌ها بدین گونه است که ماژولی که مقدار را دارد و می‌خواهد آن‌را پاس بدهد، با استفاده از سیگنال stable به ماژول گیرنده اعلام می‌کند که ورودی آماده‌ی استفاده است،
 سپس ماژول گیرنده با استفاده از سیگنال acknowledge اعلام می‌کند که ورودی را با موفقیت دریافت کرده و ماژول فرستنده می‌تواند آن را تغییر دهد.

\subsection{
    ضرب‌کنندهٔ ماتریس ترتیبی
}

در این ماژول مانند ضرب ماتریسی عادی، دو ماتریس 
$m \times m$
را در هم ضرب می‌کنیم. می‌دانیم که برای به دست آوردن درایه 
$ij$
حاصلضرب، باید سطر $i$ ام ماتریس اول را در ستون $j$ ام ماتریس دوم ضرب کنیم. برای این موضوع به ازای هر 
$1\leq i\leq m , 1\leq j\leq m $،
داریم:
$$R_{ij} = \sum_{k=0}^m{A_{ik} \times B_{kj}}،$$
که در آن،
$R$
ماتریس
$m \times m$
حاصل‌ضرب است.\\
در این ماژول برای محاسبه جمع و ضرب‌ها، از ماژول‌های جمع‌کننده و ضرب‌کننده اعشاری
\LTRfootnote{\lr{floatng point adder and multiplier}} 
 استفاده می‌کنیم.\\
ماژول ضرب‌کنندهٔ ماتریس ترتیبی
\LTRfootnote{\lr{sequential matrix multiplier}} 
 این فرایند را در قالب یک ماشین حالت انجام می‌دهد. برای محاسبه درایه $i,j$ ام، یک 
 \lr{accumulator}
 برای نگه‌داری جواب نهایی در نظر می‌گیریم و سپس
  به ازای هر $k$، ابتدا با استفاده از ماژول 
 \lr{FP\_multiplier} 
  حاصل
$A_{ik}\times B_{kj}$
 را محاسبه می‌کنیم و با استفاده از ماژول
  \lr{FP\_Adder}
 ، به ازای $k$ های مختلف جواب را آپدیت می‌کنیم.  

شکل
\ref{fig:SequentialBD}
بلوک دیاگرام ضرب‌کنندهٔ ماتریس ترتیبی را نشان می‌دهد.
باید توجه کرد که حافظه‌ای که حاوی ماتریس‌های ورودی و ماتریس جواب است، در خارج این ماژول قرار دارد.
در نتیجه، واحد کنترل در این ماشین حالت محدود
\LTRfootnote{Finite State Machine}
اندیس‌های درایه‌های موردنیاز خود، یعنی
$a_i, a_j, b_i, b_j, z_i, z_j$
را تعیین می‌کند، و مقادیر مربوط به هر درایه در ماتریس‌های ورودی در
$a_{in}$
و
$b_{in}$
قراره گرفته، و مقدار
$z_{out}$
نیز در ماتریس جواب قرار داده‌می‌شود.


\begin{figure}[t]
\centering 
\includegraphics[width=1\linewidth]{Images/SequentialBD.png}
\caption{
\centering
بلوک دیاگرام ضرب‌کنندهٔ ماتریس ترتیبی.
}\label{fig:SequentialBD}
\end{figure}

\subsection{
    ضرب‌کنندهٔ ماتریس سطری در ستونی
}

وظیفهٔ این ماژول، این است که با استفاده از یک ماژول ضرب‌کنندهٔ ماتریس ترتیبی، حاصل‌ضرب یک ماتریس سطری
$m \times n$
در یک ماتریس ستونی
$n \times m$
را محاسبه‌کند.
حاصل این ضرب، یک ماتریس
$m \times m$
خواهد بود.
\\
برای انجام این‌ کار، ابتدا ماتریس 
$m \times n$
به 
${\lceil\frac{n}{m}\rceil}$
ماتریس 
$m \times m$
تقسیم‌بندی می‌شود.
مشابهاً ماتریس 
$n \times m$
نیز به 
$\lceil\frac{n}{m}\rceil$
ماتریس 
$m \times m$
تقسیم‌بندی می‌شود.
حال با استفاده از ماژول ضرب‌کننده ماتریس ترتیبی و با توجه به این که قاعده ضرب بلوکی در ماتریس‌ها برقرار است، هر یک از این ماتریس‌های 
$m \times m$
به مانند یک عدد در نظر گرفته می‌شود و ماتریس‌های متناظر به ترتیب در هم ضرب می‌شوند.

شکل
\ref{fig:RowColBD}
بلوک دیاگرام ضرب‌کنندهٔ ماتریس سطری در ستونی است.
اندیس‌های
$a_i$
و
$b_j$
مستقیماً از ضرب‌کنندهٔ ماتریس ترتیبی حاصل می‌شوند، اما دیگر اندیس‌ها بصورت
\begin{align*}
    a_j &= mk + a_{j_{\text{seq}}}\\
    b_i &= mk + b_{i_{\text{seq}}}
\end{align*}
محاسبه می‌شوند، که در آن،
$k$
مشخص می‌کند که چندمین ماتریس
$m \times m$
در هر لحظه در حال محاسبه ضرب است، و
$a_{j_{\text{seq}}}$
و
$b_{i_{\text{seq}}}$
اندیس‌هایی هستند که ضرب‌کنندهٔ ماتریس ترتیبی تعیین کرده‌است.

\begin{figure}[t]
\centering 
\includegraphics[width=1\linewidth]{Images/RowColBD.png}
\caption{
\centering
بلوک دیاگرام ضرب‌کنندهٔ ماتریس سطری در ستونی.
}\label{fig:RowColBD}
\end{figure}



\subsection{
    ضرب‌کنندهٔ ماتریس موازی
}


این ماژول دو ماتریس 
$n \times n$
را به صورت موازی در هم ضرب می‌کند. 
به این صورت که ابتدا این ماتریس، به 
$\lceil\frac{n}{m}\rceil^2$
ماتریس 
$m \times m$
تقسیم‌بندی می‌شود.
سپس مطابق شکل
\ref{fig:ParallelMatrix}،
هر بلوک
$m \times m$
از ماتریس حاصل‌ضرب، توسط یک ضرب‌کنندهٔ ماتریس سطری در ستونی، بصورت موازی با دیگر بلوک‌های حاصل‌ضرب، محاسبه می‌شود.
در نتیجه، در این لایه، به تعداد
$\lceil\frac{n}{m}\rceil^2$،
ضرب‌کنندهٔ ماتریس سطری در ستونی ساخته می‌شود.
\begin{figure}[t]
\centering
\includegraphics[width=1\linewidth]{Images/ParallelMatrix.png}
\caption{
\centering
روش محاسبهٔ حاصل‌ضرب یک بلوک از ماتریس جواب، توسط یک ضرب‌کنندهٔ ماتریس سطری در ستونی.
}\label{fig:ParallelMatrix}
\end{figure}

\begin{figure}[t]
\centering 
\includegraphics[width=.8\linewidth]{Images/ParallelBD.png}
\caption{
\centering
بلوک دیاگرام ضرب‌کنندهٔ ماتریس موازی.
}\label{fig:ParallelBD}
\end{figure}

شکل
\ref{fig:ParallelBD}
بلوک دیاگرام ضرب‌کنندهٔ ماتریس موازی را نمایش می‌دهد.
حافظهٔ ماتریس‌های ورودی و خروجی در این ماژول موجود است، اما به علت پیچیدگی اتصالات مربوط به این حافظه‌ها، از نمایش آن‌ها در بلوک دیاگرام صرف نظر شده‌است. 

\begin{figure}[t]
\centering 
\includegraphics[width=\linewidth]{Images/HierarchicalTree.png}
\caption{
\centering
ساختار درختی سیستم.
}\label{fig:HierarchicalTree}
\end{figure}

در نهایت، ساختار درختی کل سیستم در شکل
\ref{fig:HierarchicalTree}
نمایش داده‌شده است.

\section{شبیه‌سازی و نتایج}

برای هر یک از ماژول‌های شرح داده شده در بخش قبل، یک
\lr{Testbench}
نوشته شده‌است.
مقادیر ورودی، در قالب فایل‌های باینری در پوشهٔ
\lr{data}
موجود اند و در ابتدای اجرای شبیه‌سازی، از فایل‌های مربوطه خوانده شده و در حافظه نوشته می‌شوند.
همچنین پس از اجرای عملیات ضرب ماتریس، خروجی حاصل در فایل
\lr{sim\_out.bin}
نوشته می‌شود.

برای بررسی و مقایسهٔ پاسخ‌های حاصل از شبیه‌سازی، یک مدل طلایی توسط زبان پایتون نوشته شده‌است
که ورودی‌ها و خروجی حاصل از شبیه‌سازی را دریافت کرده، و پاسخ صحیح را با پاسخ به دست آمده مقایسه می‌کند.
اجرای مدل طلایی، توسط دستور زیر قابل انجام است.

\begin{latin}
\begin{lstlisting}
python gold_standard/model.py data/<input_a address> data/<input_b address> <sim_out.bin address> <n> <k> <m>
\end{lstlisting}
\end{latin}

در ادامه به هر کدام از
\lr{Testbench}ها
به تفصیل پرداخته می‌شود.

\subsection{
    ضرب‌کنندهٔ ماتریس ترتیبی
}

برای آزمایش و شبیه‌سازی این ماژول، دو ماتریس
$4 \times 4$
به صورت زیر در هم ضرب شدند.

\tiny
\begin{align}
    \left[
        \begin{array}{c c c c}
            1&2&3&4\\
            5&6&7&8\\
            9&10&11&12\\
            13&14&15&16
        \end{array}
    \right] . \left[
        \begin{array}{c c c c}
            2&0&0&0\\
            0&2&0&0\\
            0&0&2&0\\
            0&0&0&2
        \end{array}
    \right]
    = \left[
        \begin{array}{c c c c}
            2&4&6&8\\
            10&12&14&16\\
            18&20&22&24\\
            26&28&30&32
        \end{array}
    \right]
    \label{eq:SquareMatrix}
\end{align}
\normalsize

در این
\lr{Testbench}،
ابتدا ورودی‌ها از فایل‌های مربوطه خوانده شده، سپس سیگنال
\lr{start}
مربوط به ضرب‌کنندهٔ ماتریس ترتیبی فعال می‌شود. پس از فعال شدن سیگنال
\lr{done}
در ماژول ضرب‌کننده، نتیجهٔ حاصل در فایل خروجی نوشته می‌شود.
نتیجهٔ اجرای مدل طلایی نیز بصورت زیر است.

\begin{latin}
\begin{lstlisting}[language=Bash]
> python .\gold_standard\model.py .\data\square_input_a.bin .\data\square_input_b.bin .\sim_out.bin 4 4 4
A:
[[ 1.  2.  3.  4.]
[ 5.  6.  7.  8.]
[ 9. 10. 11. 12.]
[13. 14. 15. 16.]]
B:
[[2. 0. 0. 0.]
[0. 2. 0. 0.]
[0. 0. 2. 0.]
[0. 0. 0. 2.]]
Actual:
[[ 2.  4.  6.  8.]
[10. 12. 14. 16.]
[18. 20. 22. 24.]
[26. 28. 30. 32.]]
Expected:
[[ 2.  4.  6.  8.]
[10. 12. 14. 16.]
[18. 20. 22. 24.]
[26. 28. 30. 32.]]
True
\end{lstlisting}
\end{latin}

\subsection{
    ضرب‌کنندهٔ ماتریس سطری در ستونی
}

برای آزمایش و شبیه‌سازی این ماژول، دو ماتریس
$4 \times 8$
و
$8 \times 4$
به صورت زیر در هم ضرب شدند.

\scriptsize
\begin{align*}
    &A \times B\\
    &=\left[
        \begin{array}{c c c c c c c c}
            1&2&3&4&5&6&7&8\\
            1&2&3&4&5&6&7&8\\
            1&2&3&4&5&6&7&8\\
            1&2&3&4&5&6&7&8
        \end{array}
    \right] . \left[
        \begin{array}{c c c c}
            1.5&0&0&0\\
            0&1.5&0&0\\
            0&0&1.5&0\\
            0&0&0&1.5\\
            1.5&0&0&0\\
            0&1.5&0&0\\
            0&0&1.5&0\\
            0&0&0&1.5
        \end{array}
    \right]\\
    &= \left[
        \begin{array}{c c c c}
            9&12&15&18\\
            9&12&15&18\\
            9&12&15&18\\
            9&12&15&18
        \end{array}
    \right]
\end{align*}
\normalsize

در این
\lr{Testbench}،
ابتدا ورودی‌ها از فایل‌های مربوطه خوانده شده، سپس سیگنال
\lr{start}
مربوط به ضرب‌کنندهٔ ماتریس ترتیبی فعال می‌شود. پس از فعال شدن سیگنال
\lr{done}
در ماژول ضرب‌کننده، نتیجهٔ حاصل در فایل خروجی نوشته می‌شود.
نتیجهٔ اجرای مدل طلایی نیز بصورت زیر است.

\begin{latin}
\begin{lstlisting}[language=Bash]
> python .\gold_standard\model.py .\data\row_input.bin .\data\col_input.bin .\sim_out.bin 4 8 4
A:
[[1. 2. 3. 4. 5. 6. 7. 8.]
[1. 2. 3. 4. 5. 6. 7. 8.]
[1. 2. 3. 4. 5. 6. 7. 8.]
[1. 2. 3. 4. 5. 6. 7. 8.]]
B:
[[1.5 0.  0.  0. ]
[0.  1.5 0.  0. ]
[0.  0.  1.5 0. ]
[0.  0.  0.  1.5]
[1.5 0.  0.  0. ]
[0.  1.5 0.  0. ]
[0.  0.  1.5 0. ]
[0.  0.  0.  1.5]]
Actual:
[[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]]
Expected:
[[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]
[ 9. 12. 15. 18.]]
True
\end{lstlisting}
\end{latin}
\subsection{
    ضرب‌کنندهٔ ماتریس موازی
}
برای آزمایش و شبیه‌سازی این ماژول، همان دو ماتریس
رابطه 
\ref{eq:SquareMatrix}
در هم ضرب شده‌اند. اما تفاوت در این‌جا این است که در این حالت هر یک از ماتریس‌ها، به چهار ماتریس 
$2 \times 2$
تقسیم شده‌اند.
(
    $n = 2$
)


در این
\lr{Testbench}،
ابتدا ورودی‌ها از فایل‌های مربوطه خوانده شده، سپس سیگنال
\lr{start}
مربوط به ضرب‌کنندهٔ ماتریس ترتیبی فعال می‌شود. پس از فعال شدن سیگنال
\lr{done}
در ماژول ضرب‌کننده، نتیجهٔ حاصل در فایل خروجی نوشته می‌شود.
نتیجهٔ اجرای مدل طلایی نیز بصورت زیر است.

\begin{latin}
\begin{lstlisting}[language=Bash]
> python .\gold_standard\model.py .\data\square_input_a.bin .\data\square_input_b.bin .\sim_out.bin 4 4 4
A:
[[ 1.  2.  3.  4.]
[ 5.  6.  7.  8.]
[ 9. 10. 11. 12.]
[13. 14. 15. 16.]]
B:
[[2. 0. 0. 0.]
[0. 2. 0. 0.]
[0. 0. 2. 0.]
[0. 0. 0. 2.]]
Actual:
[[ 2.  4.  6.  8.]
[10. 12. 14. 16.]
[18. 20. 22. 24.]
[26. 28. 30. 32.]]
Expected:
[[ 2.  4.  6.  8.]
[10. 12. 14. 16.]
[18. 20. 22. 24.]
[26. 28. 30. 32.]]
True
\end{lstlisting}
\end{latin}

\section{سنتز بر روی
\lr{FPGA}
و نتایج}

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{Images/FPGASettings.png}
\caption{
\centering
تنظیمات
\lr{FPGA}.
}\label{fig:FPGASettings}
\end{figure}

با استفاده از نرم‌افزار
\lr{XilinxISE}،
پروژه‌ای برای یک
\lr{FPGA}
با تنظیماتی که در شکل
\ref{fig:FPGASettings}
نمایش داده‌شده است، ساخته شد.
سپس فایل‌های
\lr{FP\_adder.v}،
\lr{FP\_multiplier.v}،
\lr{sequential\_matrix\_multipiler.v}،
\lr{row\_col\_multiplier.v}
و
\lr{parallel\_matrix\_multiplier.v} 
به
\lr{sources}
پروژه اضافه شد و
ماژول
\lr{parallel\_matrix\_multiplier}
به عنوان
\lr{System Top}
در نظر گرفته شد.

پس از تعیین منابع پروژه،
\lr{System Top}
سنتز شد.
نتایج بدست آمده از سنتز و همچنین طرح‌های شماتیک مدار نهایی در ادامه آمده‌اند.


\section{نتیجه‌گیری}


%\begin{table}[ht]
%\centering
%\caption{پارامتر‌های روش‌های دسته‌بندی.}
%\begin{tabular}[t]{ c c }
%\toprule
%روش دسته‌بندی & تعریف پارامترها\\
%\midrule
%\lr{KNN} & 
%\begin{tabular}{r l}
%تعداد نزدیک‌ترین همسایه‌ها & 3
%\end{tabular}\\
%\midrule
%بیز ساده‌انگارانه & -------\\
%\midrule
%انتشار رو به عقب &
%\begin{tabular}{r l}
%تعداد نورون لایهٔ نهان & 10\\
%نرخ یادگیری &
%$0.3$\\
%تعداد تکرار & 1000
%\end{tabular}\\
%\midrule
%\lr{NTC} &
%\begin{tabular}{r c l}
%نرخ یادگیری &
%\hspace{1cm}
%&‌$0.3$\\
%تعداد تکرار &
%\hspace{1cm}
%& 100
%\end{tabular}
%\end{tabular}
%\label{tab:NTCHyperParams}
%\end{table}

\newpage
‌
\includepdf[pages=-]{ParallelSummary.pdf}

\end{document}